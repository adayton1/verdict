/*=========================================================================

  Module:    verdict.h.in

  Copyright (c) 2006 Sandia Corporation.
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/


/*! \file verdict.h
  \brief Header file for verdict library that calculates metrics for finite elements.
    Also see: \ref index "Main Page" 
 *
 * verdict.h is the header file for applications/libraries to include
 *           to compute quality metrics.
 *
 * This file is part of VERDICT
 *
 */

// .SECTION Thanks
// Prior to its inclusion within VTK, this code was developed by the CUBIT
// project at Sandia National Laboratories. 

#ifndef __verdict_h
#define __verdict_h

#define VERDICT_VERSION @verdict_VERSION_FLAT@

#cmakedefine BUILD_SHARED_LIBS
#ifdef BUILD_SHARED_LIBS
# define VERDICT_SHARED_LIB
#endif

/*!\page VerdictAsASubProject Verdict as a Subproject
 *
 * Should a project wish to include a private version of verdict, it may
 * turn on the CMake \c VERDICT_MANGLE option and define \c VERDICT_MANGLE_PREFIX.
 * This will use the \c verdict_mangle.h file to define macros that rename all
 * verdict library symbols using the given prefix.
 *
 * This allows programs using the parent project to link to the parent project
 * as well as other versions of verdict than the one used by the parent project.
 * If you are using mangling, you should consider setting \c VERDICT_NO_LIBRARY_VERSION
 * to 1 and \c VERDICT_LIBRARY_PROPERTIES to include your parent project's shared
 * library version number.
 *
 * Here is an example. Assume we have a library named XXX which we would like to use
 * a private copy of the verdict library (instead of the version installed in a system
 * directory). The XXX project source directory would contain a copy of the verdict
 * source and the CMake file for XXX would include:\code
 *   set( VERDICT_MANGLE "ON" CACHE BOOL "XXX requires Verdict to be mangled" FORCE )
 *   set( VERDICT_MANGLE_PREFIX "xxx" CACHE STRING "Verdict routines prefixed with xxx_" FORCE )
 *   set( VERDICT_NO_LIBRARY_VERSION 1 )
 *   set( VERDICT_LIBRARY_PROPERTIES
 *     ${VERDICT_LIBRARY_PROPERTIES}
 *     VERSION "xxx${XXX_VERSION}"
 *   )
 *   add_subdirectory( verdict )
 * \endcode
 * By setting these variables before descending into the verdict directory,
 * we force all the symbol names in the library to be prefaced with \c xxx_
 * and the resulting library will be named \a xxxverdict instead of simply \a verdict.
 */
#cmakedefine VERDICT_MANGLE
#ifdef VERDICT_MANGLE
#  include "verdict_mangle.h"
#endif

#define VERDICT_DBL_MIN 1.0E-30
#define VERDICT_DBL_MAX 1.0E+30
#define VERDICT_PI 3.1415926535897932384626

#if defined(_WIN32) || defined (__CYGWIN__)
# define VERDICT_ABI_IMPORT __declspec(dllimport)
# define VERDICT_ABI_EXPORT __declspec(dllexport)
#elif __GNUC__ >= 4
# define VERDICT_ABI_IMPORT __attribute__ ((visibility("default")))
# define VERDICT_ABI_EXPORT __attribute__ ((visibility("default")))
#else
# define VERDICT_ABI_IMPORT
# define VERDICT_ABI_EXPORT
#endif

#ifdef __cplusplus
# define VERDICT_EXTERN_C extern "C"
#endif

#if defined(VERDICT_SHARED_LIB)
# ifdef verdict_EXPORTS
#  define C_FUNC_DEF VERDICT_EXTERN_C  VERDICT_ABI_EXPORT
# else
#  define C_FUNC_DEF VERDICT_EXTERN_C  VERDICT_ABI_IMPORT
# endif
#else
# define C_FUNC_DEF VERDICT_EXTERN_C
#endif

/* typedef for the user if they want to use
 *    function pointers */
#ifdef __cplusplus
extern "C" {
#endif
  typedef double(*VerdictFunction)(int, double[][3]);
  typedef int(*ComputeNormal)(double point[3], double normal[3]); 
#ifdef __cplusplus
}
#endif
                                     
/*! \mainpage
  Verdict is a library used to calculate metrics on the following type of elements:

    \li Hexahedra
    \li Tetrahedra
    \li Pyramid 
    \li Wedge 
    \li Knife 
    \li Quadrilateral
    \li Triangle
    \li Edge 

  Verdict calculates individual metrics on a single elment.  

  \section GetVerdict Obtaining, Configuring, Building, and Installing Verdict

  Since your are reading reference documentation generated from the source code,
  you ostensibly already have Verdict.
  Instructions for this are on a separate page: \ref ObtainConfigureBuildInstall .

  \section UsingVerdict Using Verdict

  Verdict functions take the parameters below and return the calculated
  metric value.

  \param num_nodes Number of nodes in the element. 
  \param coordinates 2D array containing x,y,z coordinate data of the nodes.

  Below is an example of how use Verdict's functions:

    
    Example: \code
    double quad_nodes[4][3];
 
    //node 1
    quad_node[0][0] = 0;  //x
    quad_node[0][1] = 0;  //y
    quad_node[0][2] = 0;  //z

    //node 2
    quad_node[1][0] = 1; 
    quad_node[1][1] = 0.1;
    quad_node[1][2] = 0.1;

    //node 3
    quad_node[2][0] = 0.9; 
    quad_node[2][1] = 0.9;
    quad_node[2][2] = -0.1;

    //node 4
    quad_node[3][0] = -0.05; 
    quad_node[3][1] = 1;
    quad_node[3][2] = 0;

    double my_shape      = v_quad_shape(4, quad_nodes);
    double my_distortion = v_quad_distortion(4, quad_nodes); 
    double my_area       = v_quad_area(4, quad_nodes);  
    double my_relative_size = v_quad_relative_size( 4, quad_nodes );
    \endcode

*/

/*!\page ObtainConfigureBuildInstall Obtain, Configure, Build, and Install Verdict

  \section ObtainVerdict Obtaining the Verdict Source Code

  The verdict source code repository is now maintained by <a href="http://www.kitware.com/">Kitware</a>.
  You can check out the source with \code
    cvs -d :pserver:anonymous@public.kitware.com:/cvsroot/Verdict login
    cvs -d :pserver:anonymous@public.kitware.com:/cvsroot/Verdict -z3 co Verdict
  \endcode
  When asked for a password, enter "verdict".

  \section ConfiguringVerdict Configuring Verdict

  Verdict uses <a href="http://www.cmake.org/">CMake</a> to create project files.
  To build Verdict from source, you will need to obtain CMake.
  
  We strongly suggest that you build Verdict in a separate directory tree from the source code.
  Life is just too short to explain why; if you're curious, search the CMake mailing list.
  To make the instructions clear, we'll assume that you have the Verdict source code in \c /tmp/Verdict.
  Configuring Verdict is then as simple as \code
    mkdir /tmp/VerdictBuild
    cd /tmp/VerdictBuild
    cmake ../Verdict
  \endcode
  At this point, you may wish to edit <tt>/tmp/VerdictBuild/CMakeCache.txt</tt> to change settings
  from their default values.
  
  If you are going to include Verdict inside another library, you might want to read
  how to use \ref VerdictAsASubProject.

  \section BuildingAndInstallingVerdict Building and Installing Verdict

  Assuming you are using CMake's Makefile generator, building and installing Verdict
  is accomplished with \code
    make
    make install
  \endcode
  By default, Verdict will be installed in \c /usr/local.
  If you wish to change the location, edit your <tt>CMakeCache.txt</tt> file so that
  \c CMAKE_INSTALL_PREFIX contains a different directory and re-run \c cmake.
 */

/* quality functions for hex elements */

    //! Calculates hex edge ratio metric.
    /**  Hmax / Hmin where Hmax and Hmin are respectively the maximum and the
         minimum edge lengths */ 
    C_FUNC_DEF double v_hex_edge_ratio( int num_nodes, double coordinates[][3] );

    //! Calculates hex maximum of edge ratio
    /**Maximum edge length ratio at hex center.
      Reference --- L.M. Taylor, and D.P. Flanagan, Pronto3D - A Three Dimensional Transient
         Solid Dynamics Program, SAND87-1912, Sandia National Laboratories, 1989. */
    C_FUNC_DEF double v_hex_max_edge_ratio( int num_nodes, double coordinates[][3] );

    //! Calculates hex skew metric. 
    /** Maximum |cos A| where A is the angle between edges at hex center.   
      Reference --- L.M. Taylor, and D.P. Flanagan, Pronto3D - A Three Dimensional Transient
         Solid Dynamics Program, SAND87-1912, Sandia National Laboratories, 1989. */
    C_FUNC_DEF double v_hex_skew( int num_nodes, double coordinates[][3] ); 

    //! Calculates hex taper metric 
    /**  Maximum ratio of lengths derived from opposite edges. 
      Reference --- L.M. Taylor, and D.P. Flanagan, Pronto3D - A Three Dimensional Transient
         Solid Dynamics Program, SAND87-1912, Sandia National Laboratories, 1989. */
    C_FUNC_DEF double v_hex_taper( int num_nodes, double coordinates[][3] ); 

    //! Calculates hex volume 
    /**  Jacobian at hex center. 
      Reference --- L.M. Taylor, and D.P. Flanagan, Pronto3D - A Three Dimensional Transient
         Solid Dynamics Program, SAND87-1912, Sandia National Laboratories, 1989. */
    C_FUNC_DEF double v_hex_volume( int num_nodes, double coordinates[][3] ); 

    //! Calculates hex stretch metric   
    /**  Sqrt(3) * minimum edge length / maximum diagonal length. 
      Reference --- FIMESH code */ 
    C_FUNC_DEF double v_hex_stretch( int num_nodes, double coordinates[][3] ); 

    //! Calculates hex diagonal metric   
    /** Minimum diagonal length / maximum diagonal length. 
      Reference --- Unknown */ 
    C_FUNC_DEF double v_hex_diagonal( int num_nodes, double coordinates[][3] ); 

    //! Calculates hex dimension metric   
    /** Pronto-specific characteristic length for stable time step calculation.  
        Char_length = Volume / 2 grad Volume. 
      Reference --- L.M. Taylor, and D.P. Flanagan, Pronto3D - A Three Dimensional Transient
         Solid Dynamics Program, SAND87-1912, Sandia National Laboratories, 1989. */
    C_FUNC_DEF double v_hex_dimension( int num_nodes, double coordinates[][3] ); 

    //! Calculates hex oddy metric   
    C_FUNC_DEF double v_hex_oddy( int num_nodes, double coordinates[][3] ); 

    //! Calculates hex condition metric   
    /** Average Frobenius condition number of the Jacobian matrix at 8 corners. */ 
    C_FUNC_DEF double v_hex_med_aspect_frobenius( int num_nodes, double coordinates[][3] ); 

    //! Calculates hex condition metric   
    /** Maximum Frobenius condition number of the Jacobian matrix at 8 corners.
       Reference --- P. Knupp, Achieving Finite Element Mesh Quality via 
       Optimization of the Jacobian Matrix Norm and Associated Quantities, 
       Intl. J. Numer. Meth. Engng. 2000, 48:1165-1185. */ 
    C_FUNC_DEF double v_hex_max_aspect_frobenius( int num_nodes, double coordinates[][3] ); 
    //! Calculates hex condition metric. This is a synonym for \ref v_hex_max_aspect_frobenius.
    C_FUNC_DEF double v_hex_condition( int num_nodes, double coordinates[][3] ); 

    //! Calculates hex jacobian metric   
    /** Minimum pointwise volume of local map at 8 corners & center of hex. 
       Reference --- P. Knupp, Achieving Finite Element Mesh Quality via 
       Optimization of the Jacobian Matrix Norm and Associated Quantities, 
       Intl. J. Numer. Meth. Engng. 2000, 48:1165-1185. */ 
    C_FUNC_DEF double v_hex_jacobian( int num_nodes, double coordinates[][3] ); 
    
    //! Calculates hex scaled jacobian metric   
    /** Minimum Jacobian divided by the lengths of the 3 edge vectors. 
       Reference --- P. Knupp, Achieving Finite Element Mesh Quality via 
       Optimization of the Jacobian Matrix Norm and Associated Quantities, 
       Intl. J. Numer. Meth. Engng. 2000, 48:1165-1185. */ 
    C_FUNC_DEF double v_hex_scaled_jacobian( int num_nodes, double coordinates[][3] ); 

    //! Calculates hex shear metric   
    /** 3/Mean Ratio of Jacobian Skew matrix.
       Reference --- P. Knupp, Algebraic Mesh Quality Metrics for
       Unstructured Initial Meshes, submitted for publication.  */
    C_FUNC_DEF double v_hex_shear( int num_nodes, double coordinates[][3] ); 

    //! Calculates hex shape metric.
    /** 3/Mean Ratio of weighted Jacobian matrix. 
       Reference --- P. Knupp, Algebraic Mesh Quality Metrics for
       Unstructured Initial Meshes, submitted for publication.  */
    C_FUNC_DEF double v_hex_shape( int num_nodes, double coordinates[][3] ); 

    //! Calculates hex relative size metric. 
    /** 3/Mean Ratio of weighted Jacobian matrix.
       Reference --- P. Knupp, Algebraic Mesh Quality Metrics for
       Unstructured Initial Meshes, submitted for publication.  */

    C_FUNC_DEF double v_hex_relative_size_squared( int num_nodes, double coordinates[][3], double average_hex_volume );

    //! Calculates hex shape-size metric.
    /** Product of Shape and Relative Size.
       Reference --- P. Knupp, Algebraic Mesh Quality Metrics for
       Unstructured Initial Meshes, submitted for publication.  */
    C_FUNC_DEF double v_hex_shape_and_size( int num_nodes, double coordinates[][3], double average_hex_volume );

    //! Calculates hex shear-size metric   
    /** Product of Shear and Relative Size.
       Reference --- P. Knupp, Algebraic Mesh Quality Metrics for
       Unstructured Initial Meshes, submitted for publication.  */
    C_FUNC_DEF double v_hex_shear_and_size( int num_nodes, double coordinates[][3], double average_hex_volume );

    //! Calculates hex distortion metric   
    /** {min(|J|)/actual volume}*parent volume, parent volume = 8 for hex.
       Reference --- SDRC/IDEAS Simulation: Finite Element Modeling--User's Guide */
    C_FUNC_DEF double v_hex_distortion( int num_nodes, double coordinates[][3] );

    C_FUNC_DEF double v_hex_equiangle_skew( int num_nodes, double coordinates[][3] );

/* quality functions for tet elements */

    //! Calculates tet edge ratio metric.
    /**  Hmax / Hmin where Hmax and Hmin are respectively the maximum and the
       minimum edge lengths */ 
    C_FUNC_DEF double v_tet_edge_ratio( int num_nodes, double coordinates[][3] ); 

    //! Calculates tet radius ratio metric.
    /** CR / (3.0 * IR)  where CR = circumsphere radius, IR = inscribed sphere radius.
        Reference ---  V. N. Parthasarathy et al, A comparison of tetrahedron 
        quality measures, Finite Elem. Anal. Des., Vol 15(1993), 255-261. */ 
    C_FUNC_DEF double v_tet_radius_ratio( int num_nodes, double coordinates[][3] ); 

    //! Calculates the radius ratio metric of a positively oriented tet.
    /** CR / (3.0 * IR)  where CR = circumsphere radius, IR = inscribed sphere radius
        if the element is positively-oriented.
        Reference ---  V. N. Parthasarathy et al, A comparison of tetrahedron 
        quality measures, Finite Elem. Anal. Des., Vol 15(1993), 255-261. */ 
    C_FUNC_DEF double v_tet_aspect_beta( int num_nodes, double coordinates[][3] ); 

    //! Calculates tet aspect ratio metric.
    /**  Hmax / (2 sqrt(6) r) where Hmax and r respectively denote the greatest edge 
       length and the inradius of the tetrahedron
       Reference ---  P. Frey and P.-L. George, Meshing, Hermes (2000). */ 
    C_FUNC_DEF double v_tet_aspect_ratio( int num_nodes, double coordinates[][3] ); 

    //! Calculates tet aspect gamma metric.
    /**  Srms**3 / (8.479670*V) where Srms = sqrt(Sum(Si**2)/6), Si = edge length. 
       Reference ---  V. N. Parthasarathy et al, A comparison of tetrahedron 
       quality measures, Finite Elem. Anal. Des., Vol 15(1993), 255-261. */ 
    C_FUNC_DEF double v_tet_aspect_gamma( int num_nodes, double coordinates[][3] ); 

    //! Calculates tet aspect frobenius metric.
    /** Frobenius condition number when the reference element is regular
       Reference --- P. Knupp, Achieving Finite Element Mesh Quality via 
       Optimization of the Jacobian Matrix Norm and Associated Quantities,
       Intl. J. Numer. Meth. Engng. 2000, 48:1165-1185. */
    C_FUNC_DEF double v_tet_aspect_frobenius( int num_nodes, double coordinates[][3] ); 

    //! Calculates tet minimum dihedral angle.
    /** Minimum (nonoriented) dihedral angle of a tetrahedron, expressed in degrees. */
    C_FUNC_DEF double v_tet_minimum_angle( int num_nodes, double coordinates[][3] ); 

    //! Calculates tet collapse ratio metric.
    /**  Collapse ratio */ 
    C_FUNC_DEF double v_tet_collapse_ratio( int num_nodes, double coordinates[][3] ); 

    //! Calculates tet volume.
    /** (1/6) * Jacobian at corner node.
       Reference ---  V. N. Parthasarathy et al, A comparison of tetrahedron 
       quality measures, Finite Elem. Anal. Des., Vol 15(1993), 255-261. */ 
    C_FUNC_DEF double v_tet_volume( int num_nodes, double coordinates[][3] ); 

    //! Calculates tet condition metric.
    /** Condition number of the Jacobian matrix at any corner. 
       Reference --- P. Knupp, Achieving Finite Element Mesh Quality via 
       Optimization of the Jacobian Matrix Norm and Associated Quantities,
       Intl. J. Numer. Meth. Engng. 2000, 48:1165-1185. */
    C_FUNC_DEF double v_tet_condition( int num_nodes, double coordinates[][3] ); 

    //! Calculates tet jacobian. 
    /** Minimum pointwise volume at any corner. 
       Reference --- P. Knupp, Achieving Finite Element Mesh Quality via 
       Optimization of the Jacobian Matrix Norm and Associated Quantities,
       Intl. J. Numer. Meth. Engng. 2000, 48:1165-1185. */
    C_FUNC_DEF double v_tet_jacobian( int num_nodes, double coordinates[][3] ); 

    //! Calculates tet scaled jacobian. 
    /** Minimum Jacobian divided by the lengths of 3 edge vectors 
       Reference --- P. Knupp, Achieving Finite Element Mesh Quality via 
       Optimization of the Jacobian Matrix Norm and Associated Quantities,
       Intl. J. Numer. Meth. Engng. 2000, 48:1165-1185. */
    C_FUNC_DEF double v_tet_scaled_jacobian( int num_nodes, double coordinates[][3] ); 

    //! Calculates tet shape metric.
    /** 3/Mean Ratio of weighted Jacobian matrix.
       Reference --- P. Knupp, Algebraic Mesh Quality Metrics for
       Unstructured Initial Meshes, submitted for publication. */ 
    C_FUNC_DEF double v_tet_shape( int num_nodes, double coordinates[][3] ); 

    //! Calculates tet relative size metric.
    /** Min( J, 1/J ), where J is determinant of weighted Jacobian matrix.
       Reference --- P. Knupp, Algebraic Mesh Quality Metrics for
       Unstructured Initial Meshes, submitted for publication. */ 
    C_FUNC_DEF double v_tet_relative_size_squared( int num_nodes, double coordinates[][3], double average_tet_size );

    //! Calculates tet shape-size metric.
    /** Product of Shape and Relative Size. 
       Reference --- P. Knupp, Algebraic Mesh Quality Metrics for
       Unstructured Initial Meshes, submitted for publication. */ 
    C_FUNC_DEF double v_tet_shape_and_size( int num_nodes, double coordinates[][3], double average_tet_size );

    //! Calculates tet distortion metric.
    /** {min(|J|)/actual volume}*parent volume, parent volume = 1/6 for tet.
       Reference --- SDRC/IDEAS Simulation: Finite Element Modeling--User's Guide */ 
    C_FUNC_DEF double v_tet_distortion( int num_nodes, double coordinates[][3] ); 

    //! Calculates tet equivolume skew metric.
    C_FUNC_DEF double v_tet_equivolume_skew( int num_nodes, double coordinates[][3] );

    //! Calculates tet squish index metric.
    C_FUNC_DEF double v_tet_squish_index( int num_nodes, double coordinates[][3] );

    //! Calculates tet equiangle skew metric.
    C_FUNC_DEF double v_tet_equiangle_skew( int num_nodes, double coordinates[][3] );
    
/* quality functions for pyramid elements */ 

    //! Calculates pyramid volume.
    C_FUNC_DEF double v_pyramid_volume( int num_nodes, double coordinates[][3] ); 
    //! Caluculates pyramid jacaboian based on bisecting into two tets
    C_FUNC_DEF double v_pyramid_jacobian( int num_nodes, double coordinates[][3] );

    //! Calculates pyramid scaled jacaboian based on bisecting into two tets
    C_FUNC_DEF double v_pyramid_scaled_jacobian( int num_nodes, double coordinates[][3] );

    //! Calculates the pyramid shape metric.
    /** 4 divided by the minimum mean ratio of the Jacobian matrix at each
        element corner.
        Reference -- Adaptation of Hex shape metric. */
    C_FUNC_DEF double v_pyramid_shape( int num_nodes, double coordinates[][3] );

    //! Calculates the pyramid equiangle skew metric.
    C_FUNC_DEF double v_pyramid_equiangle_skew( int num_nodes, double coordinates[][3] );


/* quality functions for wedge elements */

    //! Calculates wedge volume.
    C_FUNC_DEF double v_wedge_volume( int num_nodes, double coordinates[][3] ); 

    //! Calculates wedge edge ratio metric.
    /**  Hmax / Hmin where Hmax and Hmin are respectively the maximum and the
       minimum edge lengths */
    C_FUNC_DEF double v_wedge_edge_ratio( int num_nodes, double coordinates[][3] );

    //! Calculates wedge max aspect forbenius.
    /** max(F_0123, F_1204, F_2015, F_3540, F_4351, F_5432)
      Reference --- Adaptation of hex max aspect frobenius */
    C_FUNC_DEF double v_wedge_max_aspect_frobenius( int num_nodes, double coordinates[][3] );

    //! Calculates wedge mean aspect forbenius.
    /** 1/6 * (F_0123 + F_1204 + F+2015 + F_3540 + F_4351 + F_5432)
      Reference --- Adaptation of hex mean aspect frobenius */
    C_FUNC_DEF double v_wedge_mean_aspect_frobenius( int num_nodes, double coordinates[][3] );

    //! Calculates wedge jacobian metric.
    /** min{((L_2 X L_0) * L_3)_k}
       Reference --- Adaptation of Tet jacobian metric. */
    C_FUNC_DEF double v_wedge_jacobian( int num_nodes, double coordinates[][3]);

    //! Calculates wedge distortion metric.
    /** {min(|J|)/actual volume}*parent volume.
       Reference --- Adaptation of Hex distortion metric. */
    C_FUNC_DEF double v_wedge_distortion( int num_nodes, double coordinates[][3] );

    //! Calculates the wedge stretch
    /** Minimum of the stretch of each quadrilateral face.
        Reference -- See quadrilateral stretch */
    C_FUNC_DEF double v_wedge_max_stretch( int num_nodes, double coordinates[][3] );

    //! Calculates wedge scaled jacobian metric.
    /** Reference --- Adaptation of Hex and Tet scaled jacobian metric. */
    C_FUNC_DEF double v_wedge_scaled_jacobian( int num_nodes, double coordinates[][3] );

    //! Calculates the wedge shape metric.
    /** 3 divided by the minimum mean ratio of the Jacobian matrix at each
        element corner.
        Reference -- Adaptaation of Hex shape metric. */
    C_FUNC_DEF double v_wedge_shape( int num_nodes, double coordinates[][3] );

    //! Calculates wedge max aspect forbenius.
    /** max(F_0123, F_1204, F_2015, F_3540, F_4351, F_5432)
      Reference --- Adaptation of hex max aspect frobenius */
    C_FUNC_DEF double v_wedge_condition( int num_nodes, double coordinates[][3] );

    //! Calculates wedge equiangle skew metric
    C_FUNC_DEF double v_wedge_equiangle_skew( int num_nodes, double coordinates[][3] );


/* quality functions for knife elements */

    //! Calculates knife volume.
    C_FUNC_DEF double v_knife_volume( int num_nodes, double coordinates[][3] ); 

    
/* quality functions for edge elements */

    //! Calculates edge length. 
    C_FUNC_DEF double v_edge_length( int num_nodes, double coordinates[][3] ); 

    
/* quality functions for quad elements */

    //! Calculates quad edge ratio
    /** edge ratio
        Reference --- P. P. Pebay, Planar Quadrangle Quality
        Measures, Eng. Comp., 2004, 20(2):157-173 */
    C_FUNC_DEF double v_quad_edge_ratio( int num_nodes, double coordinates[][3] ); 

    //! Calculates quad maximum of edge ratio.
    /** Maximum edge length ratio at quad center.
       Reference --- J. Robinson, CRE Method of element testing and the 
       Jacobian shape parameters, Eng. Comput., Vol 4, 1987. */ 
    C_FUNC_DEF double v_quad_max_edge_ratio( int num_nodes, double coordinates[][3] ); 

    //! Calculates quad aspect ratio
    /** aspect ratio
        Reference --- P. P. Pebay, Planar Quadrangle Quality
        Measures, Eng. Comp., 2004, 20(2):157-173 */
    C_FUNC_DEF double v_quad_aspect_ratio( int num_nodes, double coordinates[][3] ); 

    //! Calculates quad radius ratio
    /** radius ratio
        Reference --- P. P. Pebay, Planar Quadrangle Quality
        Measures, Eng. Comp., 2004, 20(2):157-173 */
    C_FUNC_DEF double v_quad_radius_ratio( int num_nodes, double coordinates[][3] ); 

    //! Calculates quad average Frobenius aspect
    /** average Frobenius aspect
        Reference --- P. P. Pebay, Planar Quadrangle Quality
        Measures, Eng. Comp., 2004, 20(2):157-173 */
    C_FUNC_DEF double v_quad_med_aspect_frobenius( int num_nodes, double coordinates[][3] ); 

    //! Calculates quad maximum Frobenius aspect
    /** average Frobenius aspect
        Reference --- P. P. Pebay, Planar Quadrangle Quality
        Measures, Eng. Comp., 2004, 20(2):157-173 */
    C_FUNC_DEF double v_quad_max_aspect_frobenius( int num_nodes, double coordinates[][3] ); 

    //! Calculates quad skew metric.
    /** Maximum |cos A| where A is the angle between edges at quad center. 
       Reference --- J. Robinson, CRE Method of element testing and the 
       Jacobian shape parameters, Eng. Comput., Vol 4, 1987. */ 
    C_FUNC_DEF double v_quad_skew( int num_nodes, double coordinates[][3] ); 

    //! Calculates quad taper metric.
    /** Maximum ratio of lengths derived from opposite edges. 
       Reference --- J. Robinson, CRE Method of element testing and the 
       Jacobian shape parameters, Eng. Comput., Vol 4, 1987. */ 
    C_FUNC_DEF double v_quad_taper( int num_nodes, double coordinates[][3] ); 

    //! Calculates quad warpage metric.
    /** Cosine of Minimum Dihedral Angle formed by Planes Intersecting in Diagonals. 
       Reference --- J. Robinson, CRE Method of element testing and the 
       Jacobian shape parameters, Eng. Comput., Vol 4, 1987. */ 
    C_FUNC_DEF double v_quad_warpage( int num_nodes, double coordinates[][3] ); 

    //! Calculates quad area.
    /** Jacobian at quad center.
       Reference --- J. Robinson, CRE Method of element testing and the 
       Jacobian shape parameters, Eng. Comput., Vol 4, 1987. */ 
    C_FUNC_DEF double v_quad_area( int num_nodes, double coordinates[][3] ); 

    //! Calculates quad strech metric.
    /** Sqrt(2) * minimum edge length / maximum diagonal length.
       Reference --- FIMESH code. */
    C_FUNC_DEF double v_quad_stretch( int num_nodes, double coordinates[][3] ); 

    //! Calculates quad's smallest angle.
    /** Smallest included quad angle (degrees).
       Reference --- Unknown. */ 
    C_FUNC_DEF double v_quad_minimum_angle( int num_nodes, double coordinates[][3] ); 

    //! Calculates quad's largest angle.
    /** Largest included quad angle (degrees). 
       Reference --- Unknown. */ 
    C_FUNC_DEF double v_quad_maximum_angle( int num_nodes, double coordinates[][3] ); 

    //! Calculates quad oddy metric.
    C_FUNC_DEF double v_quad_oddy( int num_nodes, double coordinates[][3] ); 

    //! Calculates quad condition number metric.
    /** Maximum condition number of the Jacobian matrix at 4 corners.
       Reference --- P. Knupp, Achieving Finite Element Mesh Quality via 
       Optimization of the Jacobian Matrix Norm and Associated Quantities,
       Intl. J. Numer. Meth. Engng. 2000, 48:1165-1185. */
    C_FUNC_DEF double v_quad_condition( int num_nodes, double coordinates[][3] ); 

    //! Calculates quad jacobian.
    /** Minimum pointwise volume of local map at 4 corners & center of quad. 
       Reference --- P. Knupp, Achieving Finite Element Mesh Quality via 
       Optimization of the Jacobian Matrix Norm and Associated Quantities,
       Intl. J. Numer. Meth. Engng. 2000, 48:1165-1185. */
    C_FUNC_DEF double v_quad_jacobian( int num_nodes, double coordinates[][3] ); 

    //! Calculates quad scaled jacobian.
    /** Minimum Jacobian divided by the lengths of the 2 edge vectors. 
       Reference --- P. Knupp, Achieving Finite Element Mesh Quality via 
       Optimization of the Jacobian Matrix Norm and Associated Quantities,
       Intl. J. Numer. Meth. Engng. 2000, 48:1165-1185. */
    C_FUNC_DEF double v_quad_scaled_jacobian( int num_nodes, double coordinates[][3] ); 

    //! Calculates quad shear metric.
    /** 2/Condition number of Jacobian Skew matrix.
       Reference --- P. Knupp, Algebraic Mesh Quality Metrics for
       Unstructured Initial Meshes, submitted for publication. */
    C_FUNC_DEF double v_quad_shear( int num_nodes, double coordinates[][3] ); 

    //! Calculates quad shape metric.
    /** 2/Condition number of weighted Jacobian matrix. 
       Reference --- P. Knupp, Algebraic Mesh Quality Metrics for
       Unstructured Initial Meshes, submitted for publication. */
    C_FUNC_DEF double v_quad_shape( int num_nodes, double coordinates[][3] ); 

    //! Calculates quad relative size metric.
    /** Min( J, 1/J ), where J is determinant of weighted Jacobian matrix. 
       Reference --- P. Knupp, Algebraic Mesh Quality Metrics for
       Unstructured Initial Meshes, submitted for publication. */
    C_FUNC_DEF double v_quad_relative_size_squared( int num_nodes, double coordinates[][3], double average_quad_area );

    //! Calculates quad shape-size metric.
    /** Product of Shape and Relative Size. 
       Reference --- P. Knupp, Algebraic Mesh Quality Metrics for
       Unstructured Initial Meshes, submitted for publication. */
    C_FUNC_DEF double v_quad_shape_and_size( int num_nodes, double coordinates[][3], double average_quad_area );

    //! Calculates quad shear-size metric.
    /** Product of Shear and Relative Size. 
       Reference --- P. Knupp, Algebraic Mesh Quality Metrics for
       Unstructured Initial Meshes, submitted for publication. */
    C_FUNC_DEF double v_quad_shear_and_size( int num_nodes, double coordinates[][3], double average_quad_area );

    //! Calculates quad distortion metric.
    /** {min(|J|)/actual area}*parent area, parent area = 4 for quad.
       Reference --- SDRC/IDEAS Simulation: Finite Element Modeling--User's Guide */
    C_FUNC_DEF double v_quad_distortion( int num_nodes, double coordinates[][3] ); 

    //! Calculates the quad equiangle skew
    C_FUNC_DEF double v_quad_equiangle_skew( int num_nodes, double coordinates[][3] );

/* quality functions for triangle elements */

    //! Calculates triangle metric.
    /** edge ratio
        Reference --- P. P. Pebay & T. J. Baker, Analysis of Triangle Quality
        Measures, AMS Math. Comp., 2003, 72(244):1817-1839 */
    C_FUNC_DEF double v_tri_edge_ratio( int num_nodes, double coordinates[][3] ); 

    //! Calculates triangle metric.
    /** aspect ratio
        Reference --- P. P. Pebay & T. J. Baker, Analysis of Triangle Quality
        Measures, AMS Math. Comp., 2003, 72(244):1817-1839 */
    C_FUNC_DEF double v_tri_aspect_ratio( int num_nodes, double coordinates[][3] ); 

    //! Calculates triangle metric.
    /** radius ratio
        Reference --- P. P. Pebay & T. J. Baker, Analysis of Triangle Quality
        Measures, AMS Math. Comp., 2003, 72(244):1817-1839 */
    C_FUNC_DEF double v_tri_radius_ratio( int num_nodes, double coordinates[][3] ); 

    //! Calculates triangle metric.
    /** Frobenius aspect */
    C_FUNC_DEF double v_tri_aspect_frobenius( int num_nodes, double coordinates[][3] ); 

    //! Calculates triangle metric.
    /** Maximum included angle in triangle */
    C_FUNC_DEF double v_tri_area( int num_nodes, double coordinates[][3] ); 

    //! Calculates triangle metric.
    /** Minimum included angle in triangle */
    C_FUNC_DEF double v_tri_minimum_angle( int num_nodes, double coordinates[][3] ); 

    //! Calculates triangle metric.
    /** Maximum included angle in triangle */
    C_FUNC_DEF double v_tri_maximum_angle( int num_nodes, double coordinates[][3] ); 

    //! Calculates triangle metric.
    /** Condition number of the Jacobian matrix.
       Reference --- P. Knupp, Achieving Finite Element Mesh Quality via 
       Optimization of the Jacobian Matrix Norm and Associated Quantities,
       Intl. J. Numer. Meth. Engng. 2000, 48:1165-1185. */ 
    C_FUNC_DEF double v_tri_condition( int num_nodes, double coordinates[][3] ); 

    //! Calculates triangle metric.
    /** Minimum Jacobian divided by the lengths of 2 edge vectors. 
       Reference --- P. Knupp, Achieving Finite Element Mesh Quality via 
       Optimization of the Jacobian Matrix Norm and Associated Quantities,
       Intl. J. Numer. Meth. Engng. 2000, 48:1165-1185. */ 
    C_FUNC_DEF double v_tri_scaled_jacobian( int num_nodes, double coordinates[][3] );

    //! Calculates triangle metric.
    /**  */
    C_FUNC_DEF double v_tri_shear( int num_nodes, double coordinates[][3] ); 
    
    //! Calculates triangle metric.
    /** Min( J, 1/J ), where J is determinant of weighted Jacobian matrix. 
       Reference ---  P. Knupp, Algebraic Mesh Quality Metrics for
       Unstructured Initial Meshes, submitted for publication. */
    C_FUNC_DEF double v_tri_relative_size_squared( int num_nodes, double coordinates[][3], double average_tri_area );

    //! Calculates triangle metric.
    /** 2/Condition number of weighted Jacobian matrix. 
       Reference ---  P. Knupp, Algebraic Mesh Quality Metrics for
       Unstructured Initial Meshes, submitted for publication. */
    C_FUNC_DEF double v_tri_shape( int num_nodes, double coordinates[][3] ); 

    //! Calculates triangle metric.
    /**  Product of Shape and Relative Size. 
       Reference ---  P. Knupp, Algebraic Mesh Quality Metrics for
       Unstructured Initial Meshes, submitted for publication. */
    C_FUNC_DEF double v_tri_shape_and_size( int num_nodes, double coordinates[][3], double average_tri_area );

    //! Calculates triangle metric.
    /** {min(|J|)/actual area}*parent area, parent area = 1/2 for triangular element. 
       Reference --- SDRC/IDEAS Simulation: Finite Element Modeling--User's Guide */
    C_FUNC_DEF double v_tri_distortion( int num_nodes, double coordinates[][3] );

    //! Calculates triangle equiangle skew metric.
    C_FUNC_DEF double v_tri_equiangle_skew( int num_nodes, double coordinates[][3] );

#endif  /* __verdict_h */
